### 레퍼런스 변수의 데이터크기

앞의 어떤 데이터 타입의 주소를 저장할 지 상관 없이 레퍼런스의 메모리크기는 4byte로 동일하다.

주소를 저장할 수 있는 크기 4byte 혹은 8byte가 있을 수 있다.

하지만 특별한 경우가 없으면 레퍼런스의 크기는 4byte 이다.

### 타입 별 레퍼런스의 크기

Vehicle - maker
Car - model /Vehicle 상속
Sedan -auto /Car상속
Truck - weight /Car상속


Vehicle v;
Car c;
Sedan s;
Truck t;

타입에 상관없이 레퍼런스 변수의 크기는 4바이트로 같다. 주소를 저장하는 변수이기 때문이다.

### 타입별 인스턴스 크기

타입(클래스, 인터페이스, 배열)

new Car();
1. 수퍼클래스의 인스턴스 변수 생성
maker
2. 해당 클래스의 인스턴스 변수 생성
maker-model-기타 부가정보

new Vehicle();
1. 해당 클래스의 인스턴스 변수 생성
maker-기타 부가정보
ㄴVehicle 설계도에 따라 heap에 만든 변수들
==>Vehicle 클래스의 인스턴스
==>Vehicle 클래스의 객체
==>Vehicle 인스턴스/객체

new Sedan();
1. 수퍼클래스의 인스턴스 변수 생성
maker-model
2. 해당 클래스의 인스턴스 변수 생성
maker-medel-auto-기타부가정보

Vehicle r1 = new Vehicle();
r1은 Vehicle 클래스의 인스턴스 주소를 저장하는 변수다. = Vehicle 객체의 주소를 저장하는 변수.

Vehicle (Type = Class, interface) 

Car r1 = new Vehicle(); // 안됨!!! new Vehicle 로 만든 변수들엔 Car 설계도의 변수가 없다. 

r1 은 Car 객체의 주소를 저장하는 변수, Car 설계도에 따라 만든 인스턴스 변수가 있는 객체의 주소를 저장할 수 있다. 

Vehicle r1 = new Car(); // ok
                maker-model

수퍼클래스의 변수까지 만들었기 때문에
레퍼런스도 자식클래스의 인스턴스를 저장할 수 있는 것이다.

r1은 Vehicle 타입의 변수이기 때문에
r1.maker는 가능하지만 r1.model은 접근 불가능하다.
model에 접근하고싶다면 형변환을 해주어야한다.
((Car)r1).model


### 자료구조 다루기
배열은 고정크기를 갖는다.
배열을 늘리려면 새 배열을 만들어서 기존 배열 값을 복사해야하는데 이 과정에서 가비지가 많이 발생한다.

'연결리스트' 는 *노드*를 이용해 데이터와 데이터를 연결하여 데이터 목록을 관리한다.

1. 배열의 크기를 동적으로 늘린다. -> 배열을 늘려서 기존 배열값을 복사한다 ( 기존 배열은 가비지가 된다. )

2. 배열과 달리 데이터를 추가할 때 마다 노드를 늘리는 방식으로 데이터를 처리한다.
각각의 노드는 데이터와 다음 노드의 주소를 갖고있다.
이는 데이터가 지속적으로 추가되는 경우 배열보단 연결리스트 방식이 낫다.

