
### 의존객체 : 인스턴스 필드에 주입

App(client) ==> BoardHandler (dependency)
            사용(인스턴스를 가지고 BoardHandler의 메서드를 호출)
            ex> boardHandler.add();
BoardHandler ==> Prompt
            사용(프롬프트 인스턴스가 아닌 클래스를 가지고 메서드를 호출)
            ex> Prompt.inputString("제목? ");

> 객채 != 인스턴스
객체는 상황에 따라 해석해야한다. 클래스던 인스턴스던 메서드를 호출해야한다.
'의존객체'는 클래스냐 인스턴스냐랑 상관없다. [다른 메서드를 호출하는 것]을 의존객체라고한다. 
클래스를 가지고 메서드를 호출한다고 의존클래스냐? 아니다.

특정 메서드에서만 사용되는 경우, *일시적인 의존관계*라 한다.
여러 메서드에서 사용되는 경우 *지속적인 의존관계* 이다.
사용되는 경우에 따라 일시적인 의존관계와 지속적인 의존 관계로 설정할 수 있다.


## 클래스 간의 관계

일시적인 관계 ( 특정 메서드에서 일시적으로 사용 ) -> dependency 의존.
    -> 파라미터, 로컬 변수를 통해
지속적인 관계 ( 여러 메서드에서 지속적으로 사용 ) -> association 연관.
    -> 인스턴스 필드를 통해

어찌됐던 둘다 의존객체임

ProjectHandler  ==  MemberHandler  프로젝트 핸들러는 멤버 핸들러를 사용하지만 
.add(memberHandler);               메서드의 파라미터로 의존 객체를 받아서 사용
    .exist();                      그래서 '일시적인 의존관계'이다
.update(memberHandler);            그런데 실제적으론 일시적인 관계가 아니라 여러 메서드에서 
    .exist();                      지속적으로 사용하는 관계에 더 가깝다.


07 - a
여러 메서드에서 사용하는 의존객체라면 일시적인 관계(메서드의 파라미터,로컬변수)가 
아니라 지속적인 관계(인스턴스 필드)로 설정하는 것이 유지 보수에 좋다.

                .memberHandler 
ProjectHandler  ---------------->  MemberHandler 
.add();
.update();

프로젝트 핸들러가 지속적으로 사용할 의존 객체는 다음과 같이 인스턴스 필드로 받는다.
```java
MemberHandler memberHandler;
```
App 클래스에 미리 projectHandler가 쓸 그 변수의 주소를 저장한다
```java
projectHandler.memberHandler = memberHandler ();
```
회원 이름이 등록된 회원의 이름인지 검사할 때 사용할 MemberHandler 인스턴스는 
인스턴스 변수에 미리 주입되어 있기 때문에 파라미터로 받을 필요 없다.
this. 를 이용해 인스턴스 변수를 직접 사용하면 된다.

App에서 메서드가 사용할 의존객체를 미리 주입했기 때문에 이제 메서드를 호출할 때 
파라미터로 전달할 필요가 없다.
```java
projectHandler.add();
projectHandler.update();
```

만약 projectHandler 가 사용할 의존객체를 주입하지 않는다면, 
그 의존객체를 사용하는 메서드를 호출할 때 실행오류가 발생한다.
왜 이런 문제가 발생하는가.
    - 의존 객제 주입을 강제하지 않기 때문이다.

해결책은 의존 객체 주입을 강제화한다.
ProjectHandler의 인스턴스를 생성할 때 반드시 MemberHandler의 인스턴스를 주입하게
만들면 된다.

어떻게? 생성자 도입.

### 생성자(constructor) 선언
- 인스턴스를 생성할 때 반드시 호출되어야 하는 메서드이다.
- 생성자는 리턴타입이 없다.
- 메서드 이름이 클래스 이름과 같아야한다.
- 인스턴스를 사용하기 전에 반드시 값을 설정해야하는 인스턴스변수가 있다면, 
생성자의 파라미터로 선언하라.
- 인스턴스 변수를 유효한 값으로 초기화시킨다.
- 필요하다면 인스턴스 변수를 초기화할 때 사용할 값을 파라미터로 받을 수 있다.

- 생성자에 파라미터가 있으면 인스턴스를 생성할 때 반드시 그 값을 넘겨야한다.
- 일종의 인스턴스 변수의 값을 설정하는 것을 강제하는 효과가 있다.


```java
  public ProjectHandler(MemberHandler memberHandler) {
    this.memberHandler = memberHandler;
  }
```

이제 의존 객체는 생성자를 통해 주입받기 때문에
외부에서 인스턴스 변수에 직접 접근할 이유가 없다. 따라서 전체공개 모드에서 패키지 멤버에만 공개하는 모드로 선언한다.


### 패키지 멤버 클래스
다른 클래스 안에 선언되지 않고 별도로 선언된 클래스를 '패키지 클래스'라고 한다.
한 소스파일에 여러개의 클래스를 정의할 수 있지만 유지보수를 위해 한 파일에
하나의 클래스만 정의한다.

### nested 클래스
메인 메서드 안에 있는 클래스다.
컴파일 후 메인 메서드 안에 정의된 클래스로 별도의 .class 파일로 추출된다.
    => 따라서 main을 호출할 때마다 클래스 정의가 실행되는 것은 아니다.

이유는 사용범위를 제한하기 위해서이다.
소속 메서드 이외의 메서드 ( 메인 메서드 이외 )에선 nested 클래스를 이용할 수 없다.

### public 클래스와 (default) 클래스
default 클래스는 같은 패키지 안에서만 접근이 가능하다.
또한, 다른 패키지 안의 public 클래스를 가져와 사용할 수 없다.





