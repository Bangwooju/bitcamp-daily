### 리뷰

Score s = new Score();

s.compute(); => s에 대해서 컴퓨트라는 연산을 수행하라
s = data
compute() = operator
객체지향 분석tool에서는 메서드를 오퍼레이터라고 부른다

기존의 코드를 서브클래스에서 재정의하는 것 = 오버라이딩

new 명령으로 만든 클래스에서 먼저 메서드를 찾는다.

### 접근 범위
private      : 같은 클래스
(default)    : 같은 클래스 + 같은 패키지
protected    : 같은 클래스 + 같은 패키지 + 서브 클래스
public       : 모두

접근 권한이 없는 메서드는 오버라이딩 할 수 없다.
오버라이딩 메서드의 접근 범위를 확대하는 것은 괜찮다. 접근 범위를 상위클래스의 접근 범위대로 지정하는 것 또한 가능하다. 하지만 상위클래스의 메서드의 접근 범위를 좁히는 오버라이딩은 불가능하다.
=> private 은 오버라이딩 자체가 불가능하기 때문에 접근범위를 확대할 수 없다.

### 오버라이딩과 super 키워드
A를 상속받은 A2의 클래스 안에서
A 클래스의 메서드를 오버라이딩 한 후 메서드를 호출할 때

this.m(); 을 호출하면 A2 클래스(해당 클래스)부터 해당 메서드를 찾으면서 (찾으면) 호출하는 것이고
super.m(); 을 호출하면 수퍼클래스인 A부터 메서드를 찾는다. 

X <- X2 <- X3 <- X4
X.m1();
X.m2();

X2.m1(); overriding

X3.m2(); overriding

X4.m1(); overriding

X4 클래스에서 this.m1() = X4.m1();
              super.m1() = X2.m1();
              this.m2() = X3.m2();
              super.m2() = X3.m2();

super.m1(); 을 호출할 때 X4클래스부터 차례대로 위로 올라가면서 m1 메서드를 찾는다.  
가장 가까운 super 클래스의 m1이 X2에 있기 때문에 X2의 m1을 호출한다

this.m2(); 를 X4에서 호출할 때 X4 클래스부터 m2 메서드를 찾기 시작한다. 가장 가까운 m2가 X3 클래스에 있기 때문에 X3 클래스의 m2를 호출한다.

super.m2(); 를 X4에서 호출할 때 X3 클래스부터 m2 메서드를 찾기 시작한다. 가장 가까운 m2가 X3 클래스에 있기 때문에 X3 클래스의 m2를 호출한다.

그럼 this.m2(); 와 super.m2(); 의 클래스가 같은가? ㅇㅇ 같다!

%%% 주의 %%%%
super.super.m1(); 
obj.super.m1();
=> 이런 문법 없다.

### super 키워드 

////그림/////0421

### 레퍼런스 형변환
- 레퍼런스를 형변환 하면 오버라이딩 하기 전, 해당 클래스의 인스턴스 변수를 만들 수 있다
```java
A4 extends A3{String a = 40; boolean w = true;}
A3 extends A{int a = 30; String t = "A3";}
A {String n = "A"; String t = "A"; boolean w =true;}

A4 obj1 = new A4();
System.out.println(((A3)obj1).age);
System.out.println(((A3)obj1).working); // 없으면 수퍼 클래스의 필드를 가리킨다.
```

만약 형변환 클래스에 존재하지 않는 필드를 가리키면 오류가 난다.

```java
A4 obj1 = new A4();
System.out.println(((A)obj1).a); // 컴파일 오류
```

- 인스턴스 필드와 달리 메서드의 경우 레퍼런스에 대한 형변환에 상관 없이 실제 레퍼런스가 가리키는 클래스에서 메서드를 찾아 올라간다.

X <- X2 <- X3 <- X4
X.m1();
X.m2();

X2.m1(); overriding

X3.m2(); overriding

X4.m1(); overriding

```java
X4 x4 = new X4();
x4.m1();

((X3)x4).m1(); // X4의 m1
((X2)x4).m1(); // X4의 m1
((X)x4).m1(); // X4의 m1
```

### 오버라이딩의 리턴타입
- 오버라이딩 메서드의 리턴 타입은 서브 클래스도 가능하다. 하지만 오버라이딩의 리턴 타입은 같아야한다.

- 메서드를 오버라이딩 할 때 리턴 타입으로 수퍼클래스는 불가능하다.


### 오버라이딩과 메서드 호출
A (m())<- A2(m(),x()) <- A3(y())

```java
A a = new A2();
A a2 = new A3();
a.m(); // A2 클래스의 m
a.x(); // 컴파일 불가

((A2)a).x(); // 컴파일 가능 

a2.m(); // A2의 m호출

```
레퍼런스가 하위 클래스의 인스턴스를 가리킬 때, 레퍼런스를 통해 호출하는 메서드는 레퍼런스가 실제 가리키는 하위 클래스에서 찾아 올라 간다.
오버라이딩 메서드 호출 규칙에 따라, 레퍼런스가 실제 가리키는 객체의 클래스부터 메서드를 찾아 올라간다.

### final
- final 클래스를 상속받을 수 없다
- 메서드에 final을 붙이면 서브 클래스에서 오버라이딩 할 수 없다.
    서브클래스에서 변경하면 안되는 메서드는 final로 처리한다.

- 필드에 final 붙인 상수 필드는 생성자에서 초기화시켜야한다.
- 상수 필드는 보통 스태틱 필드로 만든다. 인스턴스마다 개별적으로 관리하지 않기 때문이다.
- 파라미터는 메서드가 호출될 때 외부의 값을 받는 용도의 변수다. 메서드 안에서 파라미터 값을 임의로 변경하게 되면 처음 받은 파라미터 값을 사용하지 못하는 상황이 발생한다. 그래서 이런 상황을 피하고자, 보통 실무에서 파라미터를 final로 선언한다.


### 캡슐화

'캡슐화' 문법은 개발자가 특정 멤버를 직접 접근하지 못하게 막는 문법이다

오직 메서드만을 통해 필드를 변경할 수 있도록 한다.
문법: 클래스 멤버나 인스턴스 멤버 선언할 때 접근 제한자(modifier)를 붙인다
접근 제한자 
- private : 클래스에 소속된 같은 멤버만 접근 가능
- (default) : 같은 패키지에 소속된 멤버만 접근 가능
- protected : 같은 패키지에 소속되거나 자손 클래스의 멤버만 접근 가능
- public : 모두 접근 가능

### 게터
특정 필드를 변경하지 못하더라도 외부에서 이 값들을 조회할 수 있는 방법을 제공해야한다. 보통 이렇게 필드 값을 *조회하는 용도*로 사용하는 메서드의 경우 메서드의 용도를 이해하기 쉽도록 메서드를 만들 경우 getXxx() 형태로 이름을 짓는다.

> get필드명(){ ... }

get으로 시작하는 이런 메서드를 게터라고 부른다.

### 세터
캡슐화로 특정 필드에 직접 접근하는 것을 막았지만, 캡슐화 되지 않은 다른 필드에 새로운 값을 저장하고 해당 필드 값을 적용해야하는 메서드를 호출하지 않았다면 연산 결과에 문제가 생긴다.

따라서 연산자에 사용하는 모든 변수를 캡슐화 한다.
그리고 직접 필드의 값을 바꾸게 하는 것이 아닌 메서드를 통해 바꾸도록 유도한다. 

즉, 필드값을 바꿀때마다 연산자를 수행해야하는 경우 그 필드의 직접 접근을 막아라. 그리고 메서드를 통해 값을 설정하게 해라.

보통 필드의 값을 설정하는 메서드는 setXxx() 으로 이름을 짓는다.

이런 메서드를 세터라고 부른다.
필드를 비공개로 막으면 값을 조회할 수 없기 때문에 해당 필드의 getter도 함께 추가해야한다. 

참고로 이런 게터와 세터는 "프로퍼티(property)" 라고 부른다.

프로퍼티 명 = 세터와 게터에서 set, get 을 제외하고 첫번째 문자를 소문자로 만든 것
```java
void setKor(){
    프로퍼티명 = "kor"
}
```
또한, 코드를 작성할 때 필드나 메서드나 공개할 것은 공개하고 공개하지 말아야하는 것은 공개하지 않는다. 기본이 비공개이고, 공개할 멤버만 공개해야하는 것이다. 그래야 클래스가 잘못 사용되는 것을 방지할 수 있다.
하지만 게터와 세터를 모든 필드에 만드는 것은 아니다. 게터만 필요하면 게터만 만들 수 있다.

oop - ex08 - a 참고하기





