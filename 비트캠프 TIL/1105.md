### let

var 은 메서드 안에서 글로벌 변수이지만 let 은 블럭 안에서만 쓰이는 블럭 변수이다.

자바는 for 문 안에 선언된 변수는 밖에서 쓸 수 없지만 자바스크립트는 for 문 안에 변수를 선언하더라도 글로벌 변수이다. 블록 안에서만 쓰고 싶다면 let 변수로 선언한다.

함수 안에 글로벌 변수와 같은 이름의 변수가 있을 경우 항상 가까이에 있는 변수가 우선이다.
그런데 로컬 변수와 이름이 같은 글로벌 변수를 사용하고 싶다면 window를 생략하지 말라!

### 배열 만들기

new Array()

1. 빈 객체 생성 empty + Object() 객체 기본 프로퍼티와 메서드 추가 -> 필수!

++ Array() 배열 기본 프로퍼티와 메서드

자바와 달리 배열 인덱스의 유효 범위를 넘어가도 예외는 발생하지 않는다. 다만 해당 항목이 없기 때문에 값이 없다는 뜻으로 undefined 가 된다.

배열을 만들 때 크기를 결정하지 않는다. 배열에 추가된 값에 따라 배열 크기(length)가 결정된다.

=> 자바스크립트의 배열은 자바의 ArrayList와 비슷하게 동작한다.  

### 자바스크립트에서 객체를 만드는 방법

new -> 빈 객체 생성 -> Object() 호출 -> 객체 기본 프로퍼티와 메서드를 추가

필요하다면 추가적인 생성자를 호출 -> 특정 객체의 역할에 필요한 프로퍼티와 메서드 추가

### of 배열

배열을 처음부터 끝까지 반복하여 값을 꺼낼 때 유용하다.

```JavaScript
var arr = ["aaa", "bbb", true, 100];
var v;
for (v of arr) { 
  // v 변수에는 인덱스가 아니라 배열에서 꺼낸 값이 저장된다.
	console.log(v);
}
```
일반 객체는 이 반복문을 사용할 수 없다. iterable 프로토콜을 구현한 객체만이 이 반복문을 사용할 수 있다.
예) Array, Map

destructuring 문법을 사용하여 key와 value를 분해하여 받는다.
```JavaScript
for (var [key, value] of obj2) { 
    console.log(key, "=", value);
}

```

들어있는 값이 배열이라면 들어있는 값의 배열을 쪼개서 출력할 수 있다.

### destructing

배열 값을 받는 일반적인 문법 

var x = ["홍길동", 20, "남자"]

x[0] = "홍길동"

x[1] = 20

x[2] = "남자"

배열 값을 분해해서 받는 문법

var [name, age, gender] = ["유관순", 17, "여자"]

name = "유관순"

age = 17

gender = "여자"

값을 분해하여 여러 변수에 받을 수 있다.

객체에서 값을 여러 변수에 분리하여 담을 때는 객체의 프로퍼티 이름과 같은 이름으로 변수를 선언한다.

=> 분해 변수의 이름과 일치하는 프로퍼티 값을 넣어준다.
객체를 분해할 때는 대괄호가 아닌 중괄호를 사용한다.

```JavaScript
var obj = new Object();
obj.name = "홍길동";
obj.age = 20;
obj.tel = "1111-1111";
obj.working = true;

var {tel, name, age, gender} = obj;
console.log(name);
console.log(age);
console.log(tel);
console.log(gender); // 객체에 지정된 이름의 프로퍼티가 없다면 undefined 이다.
```
객체에서 특정 프로퍼티 값을 분리하여 받은 후에 나머지 값을 별도의 객체에 담아서 받고 싶다면 
{변수1, 변수2, ...나머지값받을변수}

함수의 리턴 값이 배열이기 때문에 배열을 값을 destructuring 하는 문법은 같다.
배열의 중간 값을 건너 뛰고 변수에 받을 수 있다.

var [name,,,,sum,aver] = f1();

console.log(name, sum, aver);

### 함수 선언

같은 이름의 함수를 여러 개 선언해도 문법 오류가 아니다. 단지 기존 함수를 대체한다.

=> 따라서 자바스크립트는 "메서드 오버로딩"을 지원하지 않는다.

### arguments
자바스크립트의 함수는 함수를 호출할 때 전달한 값들을 보관할 배열 변수를 내장하고 있다. 

=> 그 내장 변수의 이름은 "arguments" 이다.

자바스크립트는 파라미터의 개수와 상관없이 아규먼트를 넘길 수 있기 때문에 자바의 오버로딩 문법이 자바스크립트에서는 없다. 자바는 메서드를 찾을 때 값의 타입과 개수를 이용하여 찾는다.
그러나 자바스크립트는 값의 타입이 없고 아규먼트의 개수도 의미가 없다. 그래서 자바스크립트는 같은 이름을 가진 함수를 여러 개 만들 수 없다.

Array()로 만든 오리지널 배열은 forEach() 메서드가 있다. arguments는 Array()로 만든 오리지널 배열이 아니다. => 따라서 forEach() 함수가 없다.

forEach()를 사용하고 싶다면 진짜 배열로 바꾼후 사용해야 한다.
```JavaScript
var arr = Array.from(arguments);
arr.forEach(function(value) {
    console.log(value);
 });
```

### 함수 vs 객체

객체는 프로퍼티명과 값이 들어간다.

var obj = new Object();

obj.name = "aaa";

obj.age = 20;

obj.f1 = function() {~~};

name, age, f1 = 프로퍼티

"aaa", 20, f1() = 값

함수도 객체와 같이 프로퍼티 명과 값이 들어간다.
Object() 생성자가 추가한 프로퍼티 (변수 + 메서드) + 추가한 프로퍼티 + 함수 파라미터, 리턴 값 및 몸체
```
function f(a,b) {
    console.log("합계 :")
    console.log(a+b)
}
f.age = 100;
f.working = true;

age, working = 추가한 프로퍼티
100, true = 값
a, b = 함수 파라미터
console.log("합계 :"), console.log(a+b) = 함수 몸체
```
함수도 객체이기 때문에 객체처럼 사용할 수 있다.
```
f1.age = 20;
f1.working = true;

console.log(f1.age, f1.working); // OK
```

### 익명 함수

함수 이름없이 함수를 정의할 수 있다. 이름없는 함수를 정의한 후 사용하려면 그 함수의 주소를 어딘가에 저장해야 한다.

### 함수 호이스팅
함수도 변수처럼 함수 정의를 맨 먼저 실행한다.
즉 script 태그를 실행할 때 함수 정의가 있으면 제일 먼저 실행한다.이것은 함수를 정의한 코드를 맨 위로 끌어올린다 하여 "함수 호이스팅(hoisting)"이라 한다. 

이전 스크립트 태그에서 정의한 함수나 변수는 window 객체에 보관되기 때문에 그 이후의 스크립트 태그 안에서 그대로 사용할 수 있다.

주의 ! 현재 스크립트 태그가 아닌 다음 script 태그에 정의된 함수는 호이스팅 대상이 아니다. 호이스팅은 그 script 태그를 실행할 때 수행된다.
변수 선언은 호이스팅 규칙에 따라 먼저 실행된다. 그러나 값을 할당하는 = 연산자는 현재 위치에 도달할 때 실행된다.

함수 객체를 아규먼트로 넘길 때 보통 파라미터 이름을 fn 또는 cb(callback)로 한다.

### 콜백(callback) 함수

직접 호출하는 것이 아니라 다른 함수에게 파라미터 값으로 전달하여 호출되도록 만드는 함수

```JavaScript
function play(cb) {
    console.log("계산 결과 =", cb(100, 200));
}

function plus(a, b) {return a + b;}
function minus(a, b) {return a - b;}

play(plus); // 300 호출될 함수를 파라미터로 넘긴다. 그러면 play() 가 호출해 줄 것이다.
play(minus); // -100
```

직접 호출하지 않는다고 모두 콜백함수인 것이 아니고 파라미터로 전달해서 호출했을 경우에 콜백함수이다.

```JavaScript
function play2(v1, v2, op) {
	if(op == "+") {
		console.log(plus(v1,v2)); // 파라미터로 받은 함수를 호출하는 것이 아니기 때문에 콜백 함수가 아니다.
	} else if (op == "-") {
		console.log(minus(v1,v2)); // 파라미터로 받은 함수를 호출하는 것이 아니기 때문에 콜백 함수가 아니다.
	} else {
		console.log("해당 연산을 지원하지 않습니다.");
	}
}

play2(100,200,"+");
play2(100,200,"-");
```

### 함수 리턴

함수 안에서 함수를 만들어 리턴할 수 있다.
함수 안에서 정의한 함수를 '클로저(closure)' 라고 부른다.

### 클로저

함수 안에 정의된 함수를 보통 클로저(closure)라 부른다.
inner function, nested function 이라고도 표현한다.

> 클로저의 핵심 개념 

closure에서 바깥 함수의 로컬 변수를 사용할 때, 바깥 함수의 호출이 끝나면 해당 로컬 변수가 제거되기 때문에 클로저는 존재하지 않는 변수를 사용하는 상황이 발생한다.
그래서 이런 경우를 방지하고자, 클로저에서 사용하는 바깥 함수의 로컬 변수는 클로저의 별도 메모리에 복제된다.

예를 들어 (ex03/exam11-1 참조)
createGreeting() 함수를 호출하면 로컬 변수가 만들어지고 메시지를 출력하는 function을 호출한다. function에서 console.log를 통해 메시지를 출력한다. 메서드 안에서 메서드를 만드는데 그 함수가 바깥 함수의 로컬 변수를 사용한다. 이 함수를 리턴했을 때 그 함수가 사라졌다는 뜻이다. 리턴된 함수의 변수는 무엇을 가리키는지? 

이런 상황을 방지하고자 바깥의 변수를 참조하는 경우 그 변수를 사용할 수 있도록 별도 함수 프로퍼티에 클로저가 사용하는 변수는 따로 보관한다. 클로저 메모리가 따로 존재한다.

함께 생성된 클로저끼리는 바깥 변수를 공유한다.
setValue(), getValue() 로 지정할 때 하나의 변수를 지정하는 기능을 수행할 수 있다.

### 애로우 함수

익명 함수를 정의할 때 arrow function 문법을 사용할 수 있다.

문법:
(파라미터,파라미터,...) => 문장 

(파라미터,파라미터,...) => {문장1; 문장2;}

여러 개의 문장을 가질 때는 블록{}으로 묶는다.

=> {}에서 값을 리턴하려면 return을 명시해야 한다.
```JavaScript
var f4 = (a, b) => {
    return a + b;
};
console.log(f4(100, 200));
```

### 객체 - 프로퍼티

생성자를 이용하여 기본 객체를 준비한 후에 필요한 프로퍼티(변수와 함수)를 추가할 수 있다.

기본 객체 안에는 다음의 함수들이 들어 있다.
```
console.log(obj.toString());
console.log(obj.valueOf());
console.log(obj.hasOwnProperty("toString")); // false
console.log(obj.hasOwnProperty("hashCode")); // false
```

=> hasOwnProperty()는 기본 객체를 생성한 이후에 개발자가 추가한 프로퍼티인지 검사한다.

- 객체에 값을 저장할 수 있다.
```
obj.title = "제목입니다.";
obj["content"] = "내용입니다.";
obj['viewCount'] = 120; 
```
자바와 달리 객체의 프로퍼티 변수를 사용할 때는 반드시 this를 붙여야 한다.생략하면 안된다.

자바에서는 println()에 객체 주소를 주면 println()에서 내부적으로 해당 객체의 toString() 호출한다. 그리고 그 리턴 값을 출력한다.
그러나 자바스크립트의 console.log()는 자바와 달리 toString()의 리턴 값을 출력하지 않는다.

### {} 를 이용하여 객체에 프로퍼티 추가하기
{}은 기본 객체를 생성하는 단축 문법이다. 
즉 new Object()와 같다.

{}은 기본 객체를 생성할 뿐만 아니라 프로퍼티도 바로 추가할 수 있다. 

```JavaScript
var obj = {
	name: "홍길동", 
	kor: 100, 
	eng: 90, 
	math:80,
	sum: function() {
	    return this.kor + this.eng + this.math; 
	},
	aver: function() {
	    return this.sum() / 3;
	}
}; 
```


arrow fuction을 객체의 프로퍼티로 등록할 때, arrow function에서 this는 소속된 객체가 아니라 window 객체를 가리킨다.
그에 비해 일반 함수나 익명 함수에서 사용하는 this는 자신이 소속된 객체를 가리킨다.  


### 함수를 생성자처럼 사용하기

자바스크립트는 생성자를 정의하는 문법이 따로 없다. 일반 함수를 생성자처럼 사용한다.
=> new 명령을 사용하여 외부에서 빈 객체를 생성한 후, 일반 함수를 호출한다. 외부에서 생성한 객체는 this를 통해 접근할 수 있다. 만약 new 명령없이 이 함수를 호출한다면 this는 undefined 이다.

생성자로 사용할 함수를 일반 함수처럼 사용하면 this 변수에 객체 주소가 없기 때문에 실행 오류가 발생할 것이다.
그래서 개발자가 혼동하지 않도록 생성자로 사용하는 함수는 개발자 사이에서 관례적으로 함수의 이름을 자바의 클래스처럼 대문자로 시작한다

즉 자바스크립트는 생성자 문법이 따로 없기 때문에 일반 용도의 함수와 생성자 용도의 함수를 구분하기 위해 생성자 함수는 보통 대문자로 이름을 시작한다. 

생성자 함수는 일반 함수와 다르게 메서드 이름을 명사구 형태로 짓는다.

### 인스턴스 메서드와 프로토타입 메서드

같은 함수를 두 번 호출하면 인스턴스 메서드가 중복으로 생성된다.

prototype에 추가하는 함수는 객체가 공유하는 함수이다. 생성자에 직접 추가하는 함수는 자바의 static 메서드와 같다.


