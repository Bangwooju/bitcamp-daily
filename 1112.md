### cookie 쿠키 - 클라이언트 쪽에 데이터를 맡기는 기술

쿠키 테이블에 name, value, 비고를 저장한다. 

web browser                 web server
브라우저가 서버에 요청하고 서버는 응답과 쿠키를 같이 넘겨준다. 그 쿠키 정보는 쿠키테이블에 저장되고 웹 브라우저는 다음 요청을 할 때 요청과 함께 서버에 요청 할 때 마다 그 서버가 맡긴 쿠키를 첨부하여 보낸다. 

Get /-/- HTTP/1.1
....
Cookie: 변수=값;변수=값;변수=값;
....

웹 서버
HTTP/1.1 200
...
Set-Cookie:변수=값
Set-Cookie:변수=값;부가정보(유효기간, 사용정보);

### 경로 설정

경로에서 루트가 로컬호스트 주소인지
웹브라우저 시점 - 로컬호스트 서버 주소
jsp엔진, 서블릿 컨테이너 시점 - 현재 웹 어플리케이션 루트 경로

getServletContext().getContextPath() = 현재 웹 어플리케이션 루트 경로를 알아낸다.

### 쿠키 꺼내기

쿠키를 이름으로 한 개씩 추출할 수 없다. 한 번에 배열로 받아야 한다. 요청 헤더에 쿠키가 없으면 리턴 되는 것은 빈 배열이 아니라 null이다. 따라서 무조건 반복문을 돌리면 안된다.

### 쿠키 유효기간 

유효기간을 설정하지 않으면 웹브라우저가 실행되는 동안에만 웹서버에게 쿠키를 보낸다. 웹 브라우저는 메모리에 쿠키를 보관한다.
Cookie c1 = new Cookie("v1", "aaa");

유효기간을 설정하면 웹브라우저를 종료해도 삭제되지 않는다.
단 유효기간이 지나면 웹서버에 보내지 않고 삭제한다.
=> 웹 브라우저는 로컬 디스크에 쿠키를 보관한다.
Cookie c2 = new Cookie("v2", "bbb");
c2.setMaxAge(30); // 쿠키를 보낸 이후 30초 동안만 유효
Cookie c3 = new Cookie("v3", "ccc");
c3.setMaxAge(60); // 쿠키를 보낸 이후 60초 동안만 유효

### 쿠키 사용범위

사용 범위를 지정하지 않은 쿠키는 쿠키를 발급한 서블릿과 같은 경로이거나 하위 경로의 서블릿을 요청할 때만 웹 브라우저가 서버에 쿠키를 보낸다.

사용 범위 지정 = 쿠키를 발급한 서블릿의 경로에 상관없이 지정된 경로의 서블릿을 요청할 때 웹 브라우저가 서버에 쿠키를 보낸다.

Cookie c2 = new Cookie("v2", "bbb");
c2.setPath("/eomcs-web-project/ex10/a");

왜 쿠키의 경로를 적을 때 웹 애플리케이션 루트(컨텍스트 루트)까지 적나요?
=> 쿠키 경로는 서블릿 컨테이너가 사용하는 경로가 아니다. 웹 브라우저가 사용하는 경로다.
=> 웹 브라우저에서 '/' 은 서버 루트를 의미한다. 따라서 웹 브라우저가 사용하는 경로를 지정할 때는 조심해야 한다. '/'가 서버 루트를 의미하기 때문이다.
=> 그래서 쿠키의 경로를 지정할 때는 웹 애플리케이션 루트(컨텍스트 루트)를 정확하게 지정해야 한다.

### Session

클라이언트를 식별하는 기술이다. HTTP 프로토콜은 Stateless 방식으로 통신을 한다. 즉 연결한 후 요청하고 응답을 받으면 연결을 끊는다. 그래서 서버는 클라이언트가 요청할 때 마다 누구인지 알 수 없다.
이를 해결하기 위해 클라이언트가 접속하면 웹 서버는 그 클라이언트를 위한 고유 번호를 발급(쿠키 이용)한다.
이 고유 번호를 '세션 아이디'라 부른다. 웹 브라우저는 세션 아이디를 쿠키에 보관해 두었다가 그 서버에 요청할 때 마다 세션 아이디를 보낸다.
왜? 세션 아이디는 쿠키이다.
세션 아이디를 쿠키로 보낼 때 유효기간을 설정하지 않았기 때문에 웹 브라우저를 종료하면 세션 아이디 쿠키는 삭제된다.
세션 아이디 쿠키의 사용 범위는 웹 애플리케이션이다.
예) /eomcs-java-web
따라서 같은 웹 애플리케이션의 서블릿을 실행할 때는 무조건 세션 아이디를 보낸다.

### 세션 구동 원리

web browser                 web server
웹 브라우저는 클라이언트가 보낸 쿠키에 세션ID없이 요청하면 서버는 getSessoin() 을 새로 생성해서 HttpSession 세션 객체를 생성한다. 그리고 세션 아이디를 생성하여 쿠키(세션ID)와 함께 응답한다.
getSession() 과 함께 setAttribute() 로 v1="aaa"를 같이 보낸다.

서버로 부터 받은 쿠키를 쿠키 테이블에 세션ID, 값을 저장한다. 다시 브라우저가 서버에게 요청할 때는 요청과 함께 쿠키(세션ID)를 같이 보낸다. getSession() 하면 클라이언트가 보낸 쿠키에서 세션ID를 가지고 기존에 생성된 HttpSession 객체를 찾는다. 그 후에 기존 객체 리턴한다.

getAttribute("v1")

### 세션에서 값 꺼내기

웹 브라우저를 종료하면 이전에 /ex11/s1 을 실행했을 때 서버로부터 받은 세션 아이디 쿠기가 삭제된다.
그런 후에 웹 브라우저에서 이 서블릿을 요청하면 getSession() 메서드를 새 세션 객체를 생성한 후 리턴한다. 따라서 새 세션에는 v1 이라는 이름으로 저장된 값이 없기 때문에 null을 출력할 것이다.

### Front Controller 도입 전

web brower      MemberFormController
                MemberAddController
                MemberListController

각각 개별적으로 요청
/member/form, /member/add, /member/list

### Front Controller 도입 후

web browser     <<front Controller>> DispatcherServlet
모든 요청
/member/form, /member/add, /member/list

<<Page Controller>>
MemberFormController

<<Page Controller>>
MemberListController

<<Page Controller>>
MemberAddController

DispatcherServlet 이 페이지 컨트롤러로 forward한다.
DispatcherServlet는 모든 요청을 받는다. 요청할 때 보낸 데이터를 페이지 컨트롤러가 사용하기 좋도록 가공한다. 뷰 컴포넌트(JSP) 실행, 오류 처리 페이지로 포워딩

페이지 컨트롤러는 특정 페이지에서 필요한 데이터 준비

### MVC 패턴 + Front Controller

[기존방식]
컨트롤러 - 모델 - 뷰
컨트롤러 - 모델 - 뷰

[개선]
프론트컨트롤러 - 뷰 - 페이지 컨트롤러 - 모델
                      페이지 컨트롤러 - 모델

프론트 컨트롤러 -> 기존 컨트롤러의 공통 기능을 분리하여 수행
페이지 컨트롤러 -> 페이지에 특화된 작업에 좀 더 집중







