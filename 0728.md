### 생성자 활용

- 생성자?
인스턴스를 생성한 후 그 인스턴스(값을 저장할 변수들의 묶음, 메서드X)를 제대로 쓸 수 있도록 유효한 값으로 초기화시키는 일을 하는 메서드 (O) 올바른 답변

자동으로 실행되는 메서드요 ( X ) 아주 올바르지 않은 답변

- String 클래스로 생성자호출하여 인스턴스 초기화하기
```java
String s1 = new String("Hello");
 // Hello => String literal
 // 문자열 리터럴을 사용하여 String 인스턴스를 초기화시키기.
 // String(스트링 리터럴) 생성자를 호출하여 인스턴스 초기화
```

```java
char[] chars = new char{'H','e','l','l','o'}
// char배열이 만들어 진 것

String s2 = new String(char) 
// 문자 배열을 s2의 주소값으로 넣음.
// char[] 을 사용하여 String 인스턴스 초기화시키기.
// String(char[]) 생성자를 호출하여 인스턴스 초기화
```

남이 만든 클래스를 사용할 때 매뉴얼을 보고 적절한 생성자를 사용한다.

% 주의 %
Calendar 클래스는 생성자가 없다.
기본 생성자가 protected 로 제한되어있다. protected형 생성자는 상속된 서브클래스만이 접근할 수 있다. 캘린더 클래스의 getInstance 메서드를 통해 인스턴스를 생성할 수 있다.

이렇게 자바에서 생성자의 사용 권한을 막고 메서드를 호출하여 객체를 생성하도록 유도하는 경우는 다음과 같다.
1. 같은 값을 갖는 객체를 쓸데없이 여러 개 생성하지 못하도록 하고 싶을 때   
    메모리를 절약할 수 있다.   => 이런 방법을 사용하는 설계 기법: Singleton
2. 객체 생성과정이 복잡할 때   
    객체 생성 코드를 단순하게 만들 수 있다.
    생성된 객체를 재활용할 수 있다.   => 이런 방법을 사용하는 설계 기법: Factory Method


### 상속 문법이 등장한 이유

기능 추가 방법 1: 기존 코드를 변경한다.

기존의 클래스에 코드나 기능을 계속해서 추가, 변경하여 사용하면 누더기 코드가 된다.
이는 기존 코드에 영향을 미쳐 오류를 일으키거나 유지보수가 힘들어지는 문제가 있다. 

기능 추가 방법 2: 기존 코드를 복사하여 기능을 추가, 변경한 새로운 클래스를 만든다.

기존 코드를 손대지 않기 때문에 기존 코드로 만든 프로그램에 영향을 끼치지 않는다. 깔끔하게 기능을 추가, 변경하는 것이 가능하다.
하지만 같은 기능을 하는 클래스(중복 코드)가 여러 개가 있으면 관리하기 힘들 수 있다.
원본 코드에 버그가 있다면 모든 복사 클래스에서 버그를 찾아 없애줘야한다.
기존 코드를 변경한다면 모든 복제 코드 또한 변경해야한다.
유지보수가 번거롭다.

기능 추가 방법 3: 기존의 코드를 손대지 않고 기능을 확장하는 *상속* 을 이용한다.

기존 코드를 그대로 활용하면서 새 기능만 추가한 클래스를 만든다.
extends 기존 클래스명

기존 클래스의 소스가 필요없다.
간단한 선언으로 상속 받고 새 기능만 추가하면 된다.
하지만 상속을 받는다는 전제하에 기능의 취사선택이 불가능하다. 모든 기능을 상속받는다.
기존 코드를 가져오는 것이 아닌 기존 코드를 사용한다는 의미다.
기존의 코드를 재정의 하는 것을 overriding 이라고 한다.

> 기존 방법을 안쓰겠다는 의미가 아닌 '상속' 이라는 방법을 쓸 수 있다는 의미이다.
> 무조건 상속 문법을 사용해야한다는 의미가 아니다. 상황에 따라 어느 방법이 적절한지 판단 하에 사용해야한다.

### 상속 사용
상속 받는다는 것은 수퍼 클래스의 코드를 그대로 복제해 온다는 것이 아니다.
그냥 수퍼 클래스의 코드를 사용할 수 있는 권한을 획득한다는 것이다.
메서드를 호출할 때 상속 클래스 관계에 따라 주소값의 클래스에서 상위 클래스로 찾아간다.
그래서 서브 클래스를 사용하려면 반드시 서브 클래스가 상속 받는 모든 조상 클래스가 있어야 한다. 하나의 수퍼 클래스라도 없다면 classnotfound 에러가 발생한다.

### 클래스 로딩과 인스턴스 생성 과정
new 명령을 실행하면 해당 클래스의 수퍼클래스의 인스턴스 변수부터 만든다.
수퍼클래스의 인스턴스 변수가 먼저 만들어지고 그 다음 서브 클래스의 변수가 만들어진다.
클래스 로딩 또한 수퍼클래스가 로딩되어있지 않은 상태라면 수퍼클래스가 먼저 로딩된다. *한번 클래스를 로딩하면 다시 로딩되지 않는다.*

수퍼클래스의 생성자를 먼저 '수행'한다.
서브클래스의 생성자부터 '호출'되는거고 '수행'하는 것은 수퍼클래스의 생성자부터 '수행'한다.
서브클래스의 생성자 젤 처음에 수퍼 클래스를 호출하는 명령이 들어간다.
수퍼클래스의 생성자엔 수퍼 클래스를 호출하는 명령이 없는가? 아니다. 있다.
수퍼클래스는 extends를 적지 않으면 jvm이 java.lang.Object 클래스를 컴파일러가 자동으로 추가한다.
즉, 모든 클래스엔 수퍼 클래스가 존재하며 최꼭대기엔 lang패키지의 Object 클래스가 존재한다.
> 자바의 모든 클래스의 root 클래스는 Object다.
(대충 놀라는 짤)

수퍼클래스에 선언된 인스턴스 변수 만들고 해당 클래스인 서브 클래스의 인스턴스 변수를 만든다.
그리고 그 주소를 레퍼런스에 저장한다.

인스턴스 생성할 땐 모든 수퍼클래스가 존재해야한다.
수퍼클래스 = 상속해주는 클래스
서브클래스 = 상속받는 클래스
수퍼클래스나 서브클래스는 상대적인 개념이다.

### 생성자 호출 순서
A 클래스{ v1 , A 생성자}

B 클래스 extends A { v2 , B 생성자}

C 클래스 extends B { v3 , C 생성자}

```java
new C(); // C 클래스의 기본생성자 호출
```

1. 수퍼클래스의 인스턴스 변수부터 만들어 내려온다.
만들어지면 기본값으로 초기화된다.
2. 해당 클래스(C 클래스)의 생성자가 호출된다. 
3. 모든 생성자에 첫 라인에 수퍼클래스를 호출하는 명령이 있다. 
4. A 클래스 생성자 실행 -> B 클래스 생성자 실행 -> C 클래스 생성자 실행
5. A 클래스의 수퍼클래스는 Object 클래스이다.

수퍼클래스의 어떤 생성자를 호출할지 지정하지 않으면 (첫 줄에 다른 생성자를 호출하는 코드를 넣지 않으면) 컴파일러는 다음과 같이 수퍼클래스의 기본 생성자를 호출하라는 명령을 생성자의 첫줄에 추가한다. 
super(); 
즉 개발자가 붙이지 않으면 자동으로 붙인다.
무조건 첫줄에 실행해야한다 밑에 놓으면 오류가 난다.


